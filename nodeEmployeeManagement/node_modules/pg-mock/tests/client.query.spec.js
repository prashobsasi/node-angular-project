'use strict';

const R = require('ramda');
const chai = require('chai');
const chaiAsPromised = require('chai-as-promised');
chai.use(chaiAsPromised);

const expect = chai.expect;

describe('client.query spec', function () {

  beforeEach(function (cb) {
    let self = this;
    this.pg.connect(this.conStr, function (err, client, done) {
      if (err) {
        return cb(err);
      }

      self.client = client;
      self.done = done;

      self.query = function (sql) {
        return new Promise((res, rej) => {
          self.client.query(sql, function (err, results) {
            if (err) return rej(err);
            res(results);
          });
        });
      };

      self.mock = client.mock;

      cb();
    });
  });

  afterEach(function () {
    if (typeof this.done === 'function') {
      this.done(this.client);
    }
  });

  it('client.query is ok', function () {
    expect(this.client.query).to.be.a('function');
  });

  it('sql syntax error', function () {
    return expect(this.query('sql error')).to.be.eventually.rejectedWith(Error);
  });

  context('SELECT', () => {

    it('sql SELECT asterisk', function *() {

      const sql = 'SELECT * FROM users';
      const data = this.testData.map(i => R.pick(this.wellknownColumns, i));

      const res = yield this.query(sql);

      expect(res).to.be.an('object')
        .and.have.property('rows')
        .which.to.be.an('array')
        .which.have.lengthOf(data.length);

      expect(res.rows).to.be.deep.equal(data);

    });

    it('sql SELECT all fields', function *() {

      const sql = 'SELECT id, name, balance, email, phone, registered FROM users';
      const data = this.testData.map(i => R.pick(this.wellknownColumns, i));

      const res = yield this.query(sql);

      expect(res).to.be.an('object')
        .and.have.property('rows')
        .which.to.be.an('array')
        .which.have.lengthOf(data.length);

      expect(res.rows).to.be.deep.equal(data);
    });

    it('sql SELECT one field', function *() {

      const sql = 'SELECT name FROM users';
      const data = this.testData.map(i => R.pick(['name'], i));

      const res = yield this.query(sql);

      expect(res).to.be.an('object')
        .and.have.property('rows')
        .which.to.be.an('array')
        .which.have.lengthOf(data.length);

      expect(res.rows).to.be.deep.equal(data);
    });

    it('sql SELECT WRONG field', function () {
      return expect(this.query('SELECT id2 FROM users')).to.be.eventually.rejectedWith(Error);
    });
  });

  context('INSERT', () => {

    it('sql insert Customers table, one row', function *() {

      const user = R.pick(['id', 'name'], R.head(this.testData));

      const sql = `INSERT INTO Customers(id, name) VALUES ('${user.id}', '${user.name}')`;

      yield this.query(sql);

      expect(this.mock.get()).to.be.deep.equal([user]);
    });

    it('sql insert Customers table, two rows', function *() {

      const user1 = R.pick(['id', 'name'], R.head(R.take(2, this.testData)));
      const user2 = R.pick(['id', 'name'], R.last(R.take(2, this.testData)));

      const sql = `INSERT INTO Customers(id, name) VALUES ('${user1.id}', '${user1.name}'), ('${user2.id}', '${user2.name}')`;

      yield this.query(sql);

      expect(this.mock.get()).to.be.deep.equal([ user1, user2 ]);
    });

    it('sql insert Customers table, one row x two inserts', function *() {

      const user1 = R.pick(['id', 'name'], R.head(R.take(2, this.testData)));
      const user2 = R.pick(['id', 'name'], R.last(R.take(2, this.testData)));

      yield this.query(`INSERT INTO Customers(id, name) VALUES ('${user1.id}', '${user1.name}')`);
      yield this.query(`INSERT INTO Customers(id, name) VALUES ('${user2.id}', '${user2.name}')`);

      expect(this.mock.get()).to.be.deep.equal([ user1, user2 ]);
    });

    it('sql insert Customers table, all rows and + $1000 on each balance', function *() {

      this.timeout(10000);

      const upgradedData = R.clone(this.testData).map(u => {
        u.balance = parseInt(u.balance.replace('$', ''), 10);
        u.balance = '$' + (u.balance + 1000);
        return u;
      });

      for (let user of upgradedData) {
        yield this.query(`INSERT INTO Customers(id, name, balance, email, phone, registered)
                            VALUES ('${user.id}', '${user.name}', '${user.balance}', '${user.email}', '${user.phone}', '${user.registered}')`);
      }

      expect(this.mock.verify()).to.be.ok;
    });

    it('sql INSERT WRONG table name', function () {
      const user = R.head(this.testData);
      const sql = `INSERT INTO Customers_2(id, name) VALUES ('${user.id}', '${user.name}')`;
      return expect(this.query(sql)).to.be.eventually.rejectedWith(Error);
    });

  });

  context('table names', () => {

    it('sql select Users table', function *() {

      const sql = 'SELECT * FROM Users';
      const data = this.testData.map(i => R.pick(this.wellknownColumns, i));

      const res = yield this.query(sql);

      expect(res).to.be.an('object')
        .and.have.property('rows')
        .which.to.be.an('array')
        .which.have.lengthOf(data.length);

      expect(res.rows).to.be.deep.equal(data);
    });

    it('sql SELECT WRONG table name', function () {
      return expect(this.query('SELECT * FROM Users_2')).to.be.eventually.rejectedWith(Error);
    });
  });
});
