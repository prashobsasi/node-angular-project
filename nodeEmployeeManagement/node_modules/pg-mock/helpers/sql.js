'use strict';

const R = require('ramda');
const nq = require('node-query');

const wellknownColumns = ['id', 'name', 'balance', 'email', 'phone', 'registered'];

const initData = require('../data/data.json');

function prepareSQL(sql) {

  let ast;
  try {
    ast = nq.parse(sql);
  } catch (e) {
    throw new SyntaxError(`Error parse sql "${sql}", error "${e.message}"`);
  }

  const tableName = getTableNameFromAST(ast);

  switch (ast.type) {
    case 'select':
      return {
        type: 'select',
        table: tableName,
        rows: selectData(ast)
      };
    case 'insert':
      return {
        type: 'insert',
        table: tableName,
        rows: insertData(ast)
      };
    default:
      throw new Error(`SQL operator "${ast.type}" not supported`);
  }
}

function getTableNameFromAST(ast) {

  const wellknownTables = ['users', 'customers'];

  let tableName;

  if (ast.type === 'select') {

    if (!Array.isArray(ast.from) || ast.from.length === 0) {
      throw new Error('Table name not found');
    }

    if (ast.from.length > 1) {
      throw new Error('JOINs not supported yet');
    }

    tableName = ast.from[0].table;

  } else {

    tableName = ast.table;

  }

  tableName = tableName.toLowerCase();

  if (wellknownTables.indexOf(tableName) === -1) {
    throw new Error(`Table "${tableName}" not found`);
  }

  return tableName;
}


function selectData(ast) {

  let selectedColumns;

  if (ast.columns === '*') {
    selectedColumns = [].concat(wellknownColumns);
  } else {
    selectedColumns = ast.columns.map(f => f.expr.column);
    const isKeyNotExists = f => ( wellknownColumns.indexOf(f) === -1 );
    if (selectedColumns.some(isKeyNotExists)) {
      throw new Error(`Field(s) not found, only "${wellknownColumns}" allowed`);
    }
  }

  return initData.map(i => R.pick(selectedColumns, i));
}

function insertData(ast) {

  const selectedColumns = [].concat(ast.columns);
  const isKeyNotExists = f => ( wellknownColumns.indexOf(f) === -1 );
  if (selectedColumns.some(isKeyNotExists)) {
    throw new Error(`Field(s) not found, only "${wellknownColumns}" allowed`);
  }

  return ast.values.map(group => R.zipObj(selectedColumns, group.value.map(v => v.value)));

  //console.log('!! data', data);

  //return [];
}

module.exports = {
  prepareSQL
};
