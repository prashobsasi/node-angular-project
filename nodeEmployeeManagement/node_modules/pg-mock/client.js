'use strict';

const config = require('config');

const TIME_OUT_THRESHOLD = 100 - config.thresholds.connector.timeout;
const ERROR_THRESHOLD = 100 - config.thresholds.connector.error;

const R = require('ramda');

const helper = require('./helpers');
const rnd = helper.rnd;
const parseSQL = helper.parseSQL;

const initData = require('./data/data.json');

module.exports = function (conStr) {

  let customersTable = [];

  function query(sql, params, callback) {
    if (typeof sql !== 'string') {
      return callback(new Error('sql incorrect'));
    }

    if (typeof params === 'function') {
      callback = params;
      params = [];
    }

    if (!Array.isArray(params)) {
      return callback(new Error('Params not set'));
    }

    if (typeof callback !== 'function') {
      throw new Error('Callback not set');
    }

    if (rnd(0, 100) > TIME_OUT_THRESHOLD) {
      return setTimeout(callback.bind(null, new Error('Client timeout for ' + conStr)), rnd(1000, 3000));
    }

    if (rnd(0, 100) > ERROR_THRESHOLD) {
      return setTimeout(callback.bind(null, new Error('Client error for ' + conStr)), rnd(1000, 2000));
    }

    let results;
    try {
      results = parseSQL(sql);
    } catch (e) {
      return setTimeout(callback.bind(null, e), rnd(200, 1000));
    }

    let returnedData = {
      rows: results.type === 'insert' ? [] : results.rows,
      success: true
    };

    setTimeout(callback.bind(null, null, returnedData), rnd(200, 1000));

    if (results.type === 'insert' && results.table === 'customers') {
      customersTable = customersTable.concat(results.rows);
    }
  }

  function getData() {
    return customersTable;
  }

  function verify() {
    if (initData.length !== customersTable.length) {
      return false;
    }

    const upgradedData = R.clone(initData).map(u => {
      u.balance = parseInt(u.balance.replace('$', ''), 10);
      u.balance = '$' + (u.balance + 1000);
      return u;
    });

    const diff = R.difference(upgradedData, customersTable);

    return diff.length === 0;
  }

  return {
    query,
    mock: {
      get: getData,
      verify: verify
    }
  }
};
